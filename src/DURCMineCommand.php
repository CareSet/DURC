<?php
/*
	This is the place where the actual command is orchestrated.
	it ends up being our "main()"


*/
namespace CareSet\DURC;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Symfony\Component\Process\Process;

class DURCMineCommand extends Command{

    protected $signature = 'DURC:mine {--squash} {--DB=*}';
    protected $description = 'DURC:mine generates a json representation of your database structure and relationships, by mining your DB directly.';

    public function handle(){
	//what does this do?

	echo "DURC:mine Mining database for relational structure..\n";

	$fatal_error = false;

	$databases = $this->option('DB');

	$squash = $this->option('squash');

	$db_struct = DURC::getDBStruct($databases);

	//do a pass to get all of the potential table targets

	$ignored_tables = [];

	$new_struct = [];
	$table_namespace = [];
	foreach($db_struct as $db => $table_list){
		foreach($table_list as $this_table_name => $column_data){
			
			$table_tag = strtolower($this_table_name); //lets use lowercase for linking purposes
			$last_character = substr($table_tag, -1);

			if($last_character == 's'){
				echo "Critical Error: $db->$this_table_name ends in an 's'. But Laravel tried to do smart things with plurals, which prevents autogenerated code from being easy. So for now, just rename your table so that it does not end in 's'\n";
				echo "continuing, pretending $db->$this_table_name does not exist\n";
		
			}else{
				//we only do this if the table does not end in s.
				if(isset($table_namespace[$table_tag])){	//shit
					$ignored_tables[$table_tag] = "This table name is used twice...";
				}else{
					$table_namespace[$table_tag]  = [
								'db' => $db,
								'table' => $this_table_name,
							]; //use to prevent name collisions which are on the table level, not the db.table level..
					$new_struct[$db][strtolower($this_table_name)] = [
							'table_name' => $this_table_name,
							'db' => $db,
							'column_data' => $column_data,
						];
				}
			}
		}
	}

	//in the second pass we look for links to those tables...

	//and start the second pass..
	foreach($db_struct as $this_db => $table_list){
		foreach($table_list as $this_table_name => $column_data){
			$table_tag = strtolower($this_table_name); //lets use lowercase for linking purposes
			$last_character = substr($table_tag, -1);
			if($last_character == 's'){
				//we do nothig
			}else{

				foreach($column_data as $column_index => $column_data){
					$column_name = $column_data['column_name'];
					$data_type = $column_data['data_type'];
					$is_foreign_key = $column_data['is_foreign_key'];
					$is_linked_key = $column_data['is_linked_key'];
					$foreign_db = $column_data['foreign_db'];
					$foreign_table = $column_data['foreign_table'];
               	 			$is_primary_key = $column_data['is_primary_key'];

					//we do not care about anything that does not have an '_id' at the end
					$last_three = substr($column_name,-3);
					if(strtolower($last_three) == '_id'){
				                $col_array = explode('_', $column_name);
	
						//imagine the three cases:
						// #1  something_id
						// #2 cool_something_id
						// #3 really_very_cool_something_id
	
        		       	 		$throw_away_the_id = array_pop($col_array); // we don't need _id...
                				$other_table_tag = strtolower(array_pop($col_array)); //this should always result in 'something' 
						//see if there is more to the column... enouigh to detail a relationship..
        	        			$relationship = implode('_', $col_array); //this handles both 'cool' and 'really_cool_something'
        	        			if (strlen($relationship) == 0) {
       	             				$relationship = null; //which means it the same as 'something_something_id'
	                			}
	
						$my_object_name = strtolower($this_table_name);
	
						//but if 'something' is not the name of another table.. there is no other table to link to. 
						if(isset($table_namespace[strtolower($other_table_tag)])){
								//then this table exists as a target..
							$other_table = $table_namespace[strtolower($other_table_tag)]['table'];
							$other_db = $table_namespace[strtolower($other_table_tag)]['db'];
	
							//lets fix the contents of the main $new_struct.
							$new_struct[$this_db][strtolower($this_table_name)]['column_data'][$column_index]['is_linked_key'] = true;
							$new_struct[$this_db][strtolower($this_table_name)]['column_data'][$column_index]['foreign_db'] = $other_db;
							$new_struct[$this_db][strtolower($this_table_name)]['column_data'][$column_index]['foreign_table'] = $other_table;	


							//Has Many Calculation
                    					$has_many_tmp = [
                        	    				'prefix' => $relationship,
                       	     					'type'   => $my_object_name,
								'from_table'   => $this_table_name,
								'from_db' => $this_db, 
								'from_column' => $column_name,
                	            			];
							if(is_null($relationship)){
									$has_many_key = $my_object_name;
							}else{
        	            					$has_many_key = $relationship.'_'.$my_object_name;
							}
	
							// If our foreign key is a primary key, we only have ONE
							$has_relationship_type = 'has_many';
                    					if ( $is_primary_key === true ) {
                            					$has_relationship_type = 'has_one';
                        				}
							$new_struct[$other_db][strtolower($other_table_tag)][$has_relationship_type][$has_many_key] = $has_many_tmp;



							//Belongs To Calculation
                    					$belongs_to_tmp = [
                            					'prefix' => $relationship,
                            					'type'   => $other_table_tag,
								'to_table' => $other_table,
								'to_db' => $other_db,
								'local_key' => $column_name,
                            				];
							if(is_null($relationship)){
								$belongs_to_key = $other_table_tag;
							}else{
								$belongs_to_key = $relationship.'_'.$other_table_tag;
							}
                    					$new_struct[$this_db][strtolower($my_object_name)]['belongs_to'][$belongs_to_key] = $belongs_to_tmp;

						}


					}else{ //end if(strtolower($last_three) == '_id'){
						//this column is not an _id and this process does not care about it.
					}

				}// end loop over columns for this table..

			}//end table ending in s else clause..

		}//end loop over each table in table_list

	}//end loop over every db in db_struct (to find links between tables)


	if($fatal_error){
		echo "Had Fatal Error. Exiting\n";
		exit();
	}

	//now merge db_struct and new_struct...


	//later we will support the notion of 'many_to_many' through pivot tables...
	
	//later we MAY support the notion of 'has_many_through' but that could create a rats nest...

	DURC::writeDURCDesignConfigJSON($new_struct,$squash);	

	echo "DURC:mine finished writing json configuration file\n";

    }


}
